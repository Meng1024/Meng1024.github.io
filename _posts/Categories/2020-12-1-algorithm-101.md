---
layout:     post
title:      "Algorithm 101"
subtitle:   "算法基础"
categories: Algorithm
date:       2020-12-1
author:     "Meng"
header-img: "img/post-bg-os-metro.jpg"
catalog: true
hidden: true
tags:
  - Leetcode
  - Algorithm
---

# 基础算法
## 读入
Scanner
```
import java.util.*;
import java.io.*;
public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();

    int[] arr = new int[n];
    for (int i = 0; i < n; i++) {
        arr[i] = scan.nextInt();
    }
    qsort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        System.out.print(arr[i] + (i == n - 1 ? "\n": " "));
    }
}
```
BufferedReader
```
public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(reader.readLine());
        int[] nums = new int[n];
        String[] strs = reader.readLine().split(" ");
        for (int i = 0; i < n; i++)
            nums[i] = Integer.parseInt(strs[i]);
        // ...
        reader.close(); // 记得关闭
    }
}
```


## 快速排序
### quicksort
随机选择一个数与最左交换
依次递归排左边右边
```
public static void swap(int[] arr, int x, int y) {
    int tmp = arr[x];
    arr[x] = arr[y];
    arr[y] = tmp;
    return;
}
public static void qsort(int[] arr, int l, int r) {
    if(l >= r) return;
    int index = (int)(Math.random() * (r - l + 1)) + l;
    swap(arr, index, l);

    int st = l - 1, end = r + 1;
    while(st < end) {
        while(arr[++st] < arr[l]);
        while(arr[--end] > arr[l]);
        if(st < end)swap(arr, st, end);
    }
    swap(arr, end, l);
    qsort(arr, l, end - 1);
    qsort(arr, end + 1, r);

}
```
### find Kth largest number
O(n)
```
class Main {
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    public static int findKth(int[] arr, int k, int l, int r) {
        if(l >= r) return arr[r];
        int index = (int)(Math.random() * (r - l + 1)) + l;
        swap(arr, index, l);
        int start = l - 1, end = r + 1;
        while(start < end) {
            while(arr[++start] < arr[l]);
            while(arr[--end] > arr[l]);
            if(start < end) swap(arr, start, end);
        }
        swap(arr, l, end);
        if(end - l + 1 < k) {
            return findKth(arr, k - (end - l + 1), end + 1, r);
        } else {
            return findKth(arr, k, l, end );
        }
    }
```

## Merge sort
### 归并排序
O(nlogn)
```
public static void mergeSort(int[] arr, int l, int r) {
    if(l >= r) return;
    int mid = l + r >> 1;
    mergeSort(arr, l, mid);
    mergeSort(arr, mid + 1, r);
    int k = 0; int i = l, j = mid + 1;
    int[] tmp = new int[r -l + 1];
    while(i <= mid && j <= r) {
        if(arr[i] < arr[j]) {
            tmp[k++] = arr[i++];
        } else {
            tmp[k++] = arr[j++];
        }
    }
    while(i <= mid) tmp[k++] = arr[i++];
    while(j <= r) tmp[k++] = arr[j++];
    for (i = l, j = 0; i <= r; i ++, j ++ ) arr[i] = tmp[j];
    return;
}
```

### 逆序对
O(nlogn)
```
public static long solve(int[] arr, int l, int r) {
    if(l >= r) return 0;
    int mid = l + r >> 1;
    long left = solve(arr, l, mid);
    long right = solve(arr, mid + 1, r);
    int k = 0; int i = l, j = mid + 1;
    int[] tmp = new int[r - l + 1];
    long ret = 0;
    while(i <= mid && j <= r) {
        if(arr[i] <= arr[j]) {
            tmp[k++] = arr[i++];
        } else {
            ret +=  mid - i + 1;
            tmp[k++] = arr[j++];
        }
    }
    while(i <= mid) {
        tmp[k++] = arr[i++];
    }
    while(j <= r) tmp[k++] = arr[j++];
    for (i = l, j = 0; i <= r; i ++, j ++ ) arr[i] = tmp[j];
    return left + right + ret;
}
```

## 二分
### 二分模版
O(logn)
r指向是不满足func的第一个位置。
```
public static int findL(int[] arr, int k) {
    int l = 0, r = arr.length;
    while(l < r) {
        int mid = l + (r - l) / 2;
        if(arr[mid] < k) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return r == arr.length ? -1 : arr[r] == k ? r : -1;
}
```
### 数的三次方根
```
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    double target = in.nextDouble();
    double l = -10000, r = 10000;
    while (r - l > 1e-8) {      
        double mid = (l + r) / 2;
        if (mid * mid * mid >= target)     
            r = mid;    
        else
            l = mid;
    }
    System.out.println(String.format("%.6f", l));
}
```
## 高精度
这四道题都是要注意有木有前置零。 复杂度为O(n);
### 高精度加法
```
public static String add(String a, String b) {
    StringBuilder sb = new StringBuilder();
    int i = a.length() - 1, j = b.length() - 1;
    int carry = 0;
    while (i >= 0 || j >= 0) {
        int tmp = 0;
        if(i >= 0) tmp += a.charAt(i) - '0';
        if(j >= 0) tmp += b.charAt(j) - '0';
        j--; i--;
        tmp += carry;
        sb.append(tmp % 10 + "");
        carry = tmp / 10;
    }
    if(carry != 0) sb.append(carry + "");
    return sb.reverse().toString();
}
```
### 高精度减法
比较 a 和 b 的大小，如果 a 比 b 小的话， 就算 b - a 最后加上负号
```
class Main {
    public static boolean cmp(String a, String b) {
        if(a.length() != b.length()) return a.length() > b.length();
        int i = 0;
        while(i < a.length()) {
            if(a.charAt(i) == b.charAt(i)) i++;
            else {
                int x = a.charAt(i) - '0', y = b.charAt(i) - '0';
                if(x < y) return false;
                else return true;
            }
        }
        return true;
    }
    public static String sub(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int i = a.length() - 1, j = b.length() - 1;
        int carry = 0;
        while (i >= 0 || j >= 0) {
            int x =  (a.charAt(i) - '0');
            if(j >= 0) x -= (b.charAt(j) - '0') ;
            x += carry;
            sb.append((x + 10) % 10 + "");
            carry = x < 0 ?  -1 : 0;
            j--; i--;
        }  
        //去掉前置0
        String ret = sb.reverse().toString();
        int k = 0;
        while(k < ret.length()) {
            if(ret.charAt(k) != '0') break;
            k++;
        }
        return k == ret.length() ? "0" : ret.substring(k);

    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String a = scan.next();
        String b = scan.next();
        String ret;
        //if(cmp(a, b)) System.out.println("true");
        if(cmp(a, b)) ret = sub(a, b);
        else ret = "-" + sub(b, a);
        System.out.println(ret);
    }
}
```
### 高精度乘法
这个题是一个大数乘以一个小于100000 的数, 注意处理进位的方式。。
```
public static String mul(String a, int b) {
    StringBuilder sb = new StringBuilder();
    int carry = 0;
    for(int i = a.length() - 1; i >= 0 || carry != 0; i--) {
        int v = 0;
        if(i >= 0) v = (a.charAt(i) - '0') * b;
        v += carry;
        sb.append(v % 10);
        carry = v / 10;
    }
    String ret = sb.reverse().toString();
    //remove leading zeroes;
    int k = 0;
    while(k < ret.length()) {
        if(ret.charAt(k) !=  '0') break;
        k++;
    }
    return k == ret.length() ? "0" : ret.substring(k);
}
```
### 高精度除法
```
public static String div(String a, int b) {
   StringBuilder sb = new StringBuilder();
   int r = 0;
   for(int i = 0; i < a.length(); i++) {
       r += a.charAt(i) - '0';
       sb.append(r / b);
       r %= b;
       r *= 10;
   }
   String ret = sb.toString();
   //remove leading zeroes;
   int k = 0;
   while(k < ret.length()) {
       if(ret.charAt(k) !=  '0') break;
       k++;
   }
   if(k == a.length()) return "0" + "\n" + r / 10;
   return  ret.substring(k) + "\n" + r / 10;
}
```

## 前缀和与差分
### 一维前缀和  
$S_0 = 0, S_i = a_1 + a_2 ... + a_i$  
$sum(L, R) = a_l + a_(l+1) ... + a_r = sum(R) - sum(L - 1)$
```
int[] sum = new int[n + 1];
for(int i  = 1; i < sum.length; i++) {
  sum[i] = sum[i-1] + arr[i-1];
}
```
### 二维前缀和
前缀和数组 这样更新: $s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]$  
左上$(x_1, y_1)$, 右下 $(x_2, y_2)$  矩阵面积就是 $s[x_2, y_2] - s[x_1 -1, y_2] - s[x_2, y_1 - 1] + s[x_1 - 1, x_2 - 1]$

```
class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt(), k = scan.nextInt();
        int[][] s = new int[n + 1][m + 1];

        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                s[i][j] = scan.nextInt();
            }
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + s[i][j];
            }
        }
        for(int i = 0;  i < k; i++) {
            int x1 = scan.nextInt(), y1 = scan.nextInt(), x2 = scan.nextInt(), y2 = scan.nextInt();
            System.out.println(s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
        }
    }
}
```
### 差分数组
给定a[1], a[2], ... , a[n]  
构造差分数组使得差分数组是原数组的前缀和数组 a[i] = b[1] + b[2] + ... + b[i]

核心操作:  
将a[L~R]全部加上c 等价于 b[L] += c, b[R + 1] -= c

```
AC797
class Main {
    public static void insert(int[] arr, int l, int r, int c) {
        arr[l] += c;
        arr[r + 1] -= c;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), k = scan.nextInt();
        int[] arr = new int[100010];
        for(int i = 0; i < n; i++) {
            int v = scan.nextInt();
            insert(arr, i, i, v);
        }
        while(k > 0) {
            int l = scan.nextInt(), r = scan.nextInt(), v= scan.nextInt();
            insert(arr, l - 1, r - 1, v);
            k--;
        }

        int tmp = 0;
        for(int i = 0; i < n; i++) {
            tmp += arr[i];
            System.out.print(tmp + " ");
        }
    }
}
```

### 二维差分矩阵
给定原矩阵a[i, j], 构造差分矩阵使得a是s的二维前缀和。
核心操作： 给以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的子矩阵中所有数a[i,j]加上c
等价于在差分矩阵 做如下修改
 ```
 s[x1,y1] += c
 s[x2 + 1,y1] -= c
 s[x1, y2 + 1] -= c
 s[x2 + 1, y2 + 1] += c
```

```
class Main {
    public static void insert(int[][] s, int x1, int y1, int x2, int y2, int c) {
         s[x1][y1] += c;
         s[x2 + 1][y1] -= c;
         s[x1][y2 + 1] -= c;
         s[x2 + 1][y2 + 1] += c;
    }
    public static void main(String[] args) throws IOException {
        Scanner scan = new Scanner(System.in);
        OutputStreamWriter writer = new OutputStreamWriter(System.out);
        int n = scan.nextInt(), m = scan.nextInt(), k = scan.nextInt();
        int[][] s = new int[n + 2][m + 2];
        for(int i = 1; i <= n ; i++) {
            for(int j = 1; j <= m; j++) {
                int v = scan.nextInt();
                insert(s, i, j, i, j, v);
            }
        }

        while(k > 0) {
            int x1 = scan.nextInt(), y1 = scan.nextInt();
            int x2 = scan.nextInt(), y2 = scan.nextInt();
            int c = scan.nextInt();
            insert(s, x1, y1, x2, y2, c);
            k--;
        }
        int tmp = 0;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
                writer.write(s[i][j] + " ");
            }
            writer.write("\n");
        }
        writer.flush();
        scan.close();
        writer.close();
    }
}
```
## 双指针
### 最长连续不重复子序列
滑动窗口经典例题
```
int[] window = new int[100010];
int ret = 1;
for(int i = 0, j = 0; j < n; j++) {
    window[arr[j]]++;
    while( i < j && window[arr[j]] > 1) {
        window[arr[i]]--;
        i++;
    }
    ret = Math.max(ret, j - i + 1);
}
```

###  数组元素的目标和
给定两个排好序的且没有重复元素的数组，找出从两个数组选出两个元素和为 k 的下标
```
public static int[] solve(int[] s, int[] t, int k) {
   int j = 0, ret = 0;
   for(int i = 0; i < s.length; i++) {
       j = t.length - 1;
       while(j >= 0 && s[i] + t[j] > k) {
           j--;
       }
       if(s[i] + t[j] == k) return new int[]{i, j};
   }
   return new int[0];
}
```

### 判断子序列
```
public static boolean isSeq(int[] a, int[] b) {
    if(a.length > b.length) return false;
    int i = 0, j = 0;
    while(i < a.length && j < b.length) {
        if(a[i] == b[j]) {
            i++; j++;
        } else {
            j++;
        }
    }
    return i == a.length;
}
```

## 位运算
常用位运算操作：
1. 求n的第k位数字 n >> k & 1
2. 返回n的最后一位1 lowbit(n) = n & -n;

### 二进制中1的个数
```
public static int getBit(int n) {
    int ret = 0;
    while(n != 0) {
        n -= n & -n;
        ret++;
    }
    return ret;
}
```

## 离散化
主要是映射。。。
```
import java.util.*;
import java.io.*;
class Main {
    public static int getIndex(List<Integer> list, int v) {
        int l = 0, r = list.size();
        while(l < r) {
            int mid = l + (r - l) / 2;
            if(list.get(mid) <= v) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return r == 0 ? 0 : r-1;
    }
    public static List<Integer> helper(List<Integer> list) {
        List<Integer> ret = new ArrayList<>();
        ret.add(list.get(0));
        for(int i : list) {
            ret.add(i + 1);
        }
        return ret;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();

        TreeMap<Integer, Integer> tree = new TreeMap<>();
        for(int i = 0; i < n; i++) {
            int k = scan.nextInt(), v = scan.nextInt();
            tree.putIfAbsent(k, 0);
            tree.put(k, tree.get(k) + v);
        }
        List<Integer> list = new ArrayList(tree.keySet());

        int[] sum = new int[list.size() + 1];
        for(int i = 1; i < sum.length; i++) {
            sum[i] = sum[i - 1] + tree.get(list.get(i - 1));
            //System.out.print(sum[i] + " ");
        }
        list = helper(list);

        while(m > 0) {
            int l = scan.nextInt(), r = scan.nextInt();
            l = getIndex(list, l);
            r = getIndex(list, r+1);
            //System.out.println(list.get(l) + " " + list.get(r));
            System.out.print(sum[r] - sum[l] + "\n");
            m--;
        }
    }
}
```

## 区间合并
```
Collections.sort(list, (a, b) -> (a[0] - b[0]));
int[] cur = list.get(0);
int ret = 1;
for(int i = 1; i < list.size(); i++) {
    int[] next = list.get(i);
    if(cur[1] < next[0]) {
        ret++;
        cur = next;
    } else {
        cur[1] = Math.max(cur[1], next[1]);
    }
}
```
# 数据结构
## 单链表
```
class LinkList {
    int N = 100010;
    // head 表示头结点的下标
    // e[i] 表示节点i的值
    // ne[i] 表示节点i的next指针是多少
    // idx 存储当前已经用到了哪个点
    int head, idx;
    int[] e, ne;
    public LinkList() {
        head = -1;
        idx = 0;
        e = new int[N];
        ne = new int[N];
        //Arrays.fill(ne, -1);
    }
    public void insertH(int v) {
        e[idx] = v;
        ne[idx] = head;
        head = idx++;
    }
    public void deleteK(int k) {
        if(k == -1) {
            head = ne[head];
            return;
        }
        ne[k] = ne[ne[k]];
    }
    public void insertK(int k, int v) {
        if(k == -1) {
            insertH(v);
            return;
        }
        e[idx] = v;
        ne[idx] = ne[k];
        ne[k] = idx++;
    }
    public void print() {
        for (int i = head; i != -1; i = ne[i]) {
            System.out.print(e[i] + " ");
        }
    }
}
```
## 双链表
```
class LinkList {
    int N = 100010;
    int idx;
    int[] e, l, r;
    public LinkList() {
        l = new int[N];
        r = new int[N];
        e = new int[N];
        r[0] = 1;
        l[1] = 0;
        idx = 2;
    }
    public void insert(int a, int x) {
        e[idx] = x;
        l[idx] = a;
        r[idx] = r[a];
        l[r[a]] = idx;
        r[a] = idx++;
    }
    public void remove(int a) {
        l[r[a]] = l[a];
        r[l[a]] = r[a];
    }
    public void print() {
        for(int i = r[0]; i != 1; i = r[i]) {
            System.out.print(e[i] + " ");
        }
    }
}
```

## 栈
```
class Main {
    public static void main(String[] args) {
        int n = 100010;
        int[] stack = new int[n];
        int idx = -1;
        Scanner scan = new Scanner(System.in);
        int m = scan.nextInt();
        while(m > 0) {
            String op = scan.next();
            int v;
            switch(op) {
                case "push":
                    v = scan.nextInt();
                    stack[++idx] = v;
                    break;
                case "pop":
                    idx--;
                    break;
                case "empty":
                    if(idx == -1) System.out.println("YES");
                    else System.out.println("NO");
                    break;
                case "query":
                    System.out.println(stack[idx]);
            }
            m--;
        }
    }
}
```

## 队列
```
class Main {
    public static void main(String[] args) {
        int n = 100010;
        int[] queue = new int[n];
        int h = -1, t = -1;
        Scanner scan = new Scanner(System.in);
        int m = scan.nextInt();
        while(m > 0) {
            String op = scan.next();
            switch(op) {
                case "push" :
                    int k = scan.nextInt();
                    queue[++t] = k;
                    break;
                case "empty":
                    if(h == t) System.out.println("YES");
                    else System.out.println("NO");
                    break;
                case "pop":
                    h++;
                    break;
                case "query" :
                    System.out.println(queue[h + 1]);
            }
            m--;
        }
    }
}
```

## 单调栈
```
for(int i = 0; i < n; i++) {
    while(stack.size() != 1 && arr[stack.peek()] >= arr[i]) stack.pop();
    if(stack.size() == 1) System.out.print("-1 ");
    else System.out.print(arr[stack.peek()] + " ");
    stack.push(i);
}
```

## 滑动窗口
输出选定区间大小为k的最大值和最小值。
```
public static void solve(int[] arr, int k) {
    Deque<Integer> queue = new LinkedList<>();

    for(int i = 0; i < arr.length; i++) {
        while(!queue.isEmpty() && queue.peekFirst() < i - k + 1) queue.pollFirst();
        while(!queue.isEmpty() && arr[queue.peekLast()] >= arr[i]) queue.pollLast();
        queue.offer(i);
        if(i >= k - 1) System.out.print(arr[queue.peekFirst()] + " ");
    }
    System.out.println();
    queue.clear();
    for(int i = 0; i < arr.length; i++) {
        while(!queue.isEmpty() && queue.peekFirst() < i - k + 1) queue.pollFirst();
        while(!queue.isEmpty() && arr[queue.peekLast()] <= arr[i]) queue.pollLast();
        queue.offer(i);
        if(i >= k - 1) System.out.print(arr[queue.peekFirst()] + " ");
    }
}
```

## KMP
对模版串预处理后缀和前缀最大是多少。
```
public static void solve(char[] s, char[] p) {
    int[] ne = new int[100010];
    ne[0] = -1;
    for (int i = 1, j = -1; i < p.length; i ++ ) {
        while (j >= 0 && p[j + 1] != p[i]) j = ne[j];
        if (p[j + 1] == p[i]) j ++ ;
        ne[i] = j;
    }

    for (int i = 0, j = -1; i < s.length; i ++ ) {
        while (j != -1 && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == p.length - 1) {
            System.out.println(i - j + " ");
            j = ne[j];
        }
    }
}
```

## Trie
### Trie 字符串统计
```
class Trie {
    Trie[] trie;
    int cnt = 0;
    public Trie() {
        this.trie = new Trie[26];
    }
    public void insert(String s) {
        Trie root = this;
        for(int i = 0; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a';
            if(root.trie[idx] != null) root = root.trie[idx];
            else {
                root.trie[idx] = new Trie();
                root = root.trie[idx];
            }
        }
        root.cnt++;
    }
    public int query(String s) {
        Trie root = this;
        for(int i = 0; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a';
            if(root.trie[idx] != null) root = root.trie[idx];
            else {
                return 0;
            }
        }
        return root.cnt;
    }
}
```

### 最大异或对
```
class Trie {
    Trie[] trie;
    int cnt = 0;
    public Trie() {
        this.trie = new Trie[2];
    }
    public void insert(int v) {
        Trie root = this;
        for(int i = 30; i >= 0; i--) {
            int idx = (v >> i & 1);
            if(root.trie[idx] == null) root.trie[idx] = new Trie();
            root = root.trie[idx];
        }
    }
    public int search(int v) {
        Trie root = this;
        int ret = 0;
        for(int i = 30; i >= 0; i--) {
            int idx = (v >> i & 1 ) == 1 ? 0 : 1;
            if(root.trie[idx] != null) {
                root = root.trie[idx];
                ret += (1 << i);
            }
            else if (root.trie[1 - idx] != null) {
                root = root.trie[1 - idx];
            } else {
                return 0;
            }
        }
        return ret;
    }
}
```

## 并查集
### 合并集合
```
public static void union(int[] uf, int x, int y) {
     int rx = find(uf, x), ry = find(uf, y);
     if(rx == ry) return;
     uf[rx] = ry;
 }
 public static int find(int[] uf, int x) {
     if(x == uf[x]) return x;
     uf[x] = find(uf, uf[x]);
     return uf[x];
 }
```

### 连通块中点的数量
```
class Main {
    public static void union(int[] uf, int[] cnt, int x, int y) {
        int rx = find(uf, x), ry = find(uf, y);
        if(rx == ry) return;
        cnt[ry] += cnt[rx];
        uf[rx] = ry;
    }
    public static int find(int[] uf, int x) {
        if(x == uf[x]) return x;
        uf[x] = find(uf, uf[x]);
        return uf[x];
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();
        int[] uf = new int[n + 1];
        int[] cnt = new int[n + 1];
        Arrays.fill(cnt, 1);
        for(int i = 0; i < uf.length; i++) uf[i] = i;
        while(m > 0) {
            String op = scan.next();
            if(op.equals("Q2")) {
                int v = scan.nextInt();
                int r = find(uf, v);
                System.out.println(cnt[r]);
            } else {
                int x = scan.nextInt(), y = scan.nextInt();
                if(op.equals("C")) union(uf, cnt, x, y);
                if(op.equals("Q1")) System.out.println(find(uf, x) == find(uf, y) ? "Yes" : "No");
            }
            m--;
        }
    }
}
```

### 食物链
```
class Main {
    public static int find(int[] uf, int x, int[] d) {
        if(uf[x] == x) return x;
        //这里不能直接更新uf[x]，否则距离就不是父亲节点到root节点的距离了。
        int t = find(uf, uf[x], d);
        d[x] += d[uf[x]];
        uf[x] = t;
        return uf[x];
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();
        int[] uf = new int[n + 1];
        for(int i = 0; i < uf.length; i++) uf[i] = i;
        int[] d = new int[n + 1];
        int ret = 0;
        while(m > 0) {
            int l = scan.nextInt(), x = scan.nextInt(), y = scan.nextInt();
            if(x > n || y > n) {
                ret++;
            } else {
                int px = find(uf, x, d);
                int py = find(uf, y, d);
                if(l == 1) {
                    if(px == py) {
                        if ((d[x] - d[y]) % 3 != 0) ret++;;
                    } else {
                        uf[px] = py;
                        // px ---? -- py
                        // | d[x]     | d[y]
                        // x          y
                        // (d[x] + ? - d[y]) % 3 = 0; => ? = d[y] - d[x];  
                        d[px] = d[y] - d[x];
                    }
                }
                if(l == 2) {
                    if(px == py) {
                        if((d[x] - d[y] - 1) % 3 != 0) ret++;
                    } else {
                        // 同理， dx + ? -dy = 1
                        uf[px] = py;
                        d[px] = d[y] + 1 - d[x];
                    }
                }
            }
            m--;
        }
        System.out.print(ret);
    }
}
```

## 堆
stl 支持前3个操作。
1. 插入一个数: heap[++szie], up(size)
2. 求最小值: heap[1]
3. 删除最小值: heap[1] = heap[size--], down(1)
4. 删除任意一个值: heap[k] = heap[size--], down(k), up(k);
5. 修改任意一个值: heap[k] = x; down(k), up(k)

堆：满二叉树，除了最后一行都是满的。且最后一行从左向右依次排布的。  
小根堆性质： 每一个节点都是小于孩子节点的。

堆的存储：一维数组存储。 1号点为根节点， 那么左儿子的坐标 2x， 右儿子 2x + 1
堆的两个操作：
1. down(x) : 往下调整
2. up(x)： 往上调整

建堆：
1. 一个一个插入元素: O(nlogn)
2. 从 n/2 开始往下down: O(n)  
因为是从底向上建的，这样，有1/2的元素向下比较了一次，有1/4的向下比较了两次，1/8的，向下比较了3次 ,..., 1/2^k的向下比较了k次，其中1/2^k <= 1。 所以所有移动的总和为 $\sum_{k=1}^{logn} \Big[\frac{n}{2^{k}} * k\Big]$ 所以最后经过计算就是 O(n)

### 堆排序
```
class Heap {
    int size;
    int[] heap;
    public Heap(int[] h) {
        size = h.length - 1;
        this.heap = h;
        build();
    }
    //建堆
    public void build() {
        for (int i = size / 2; i > 0; i -- ) down(i);
    }
    public void down(int i) {
        int idx = i;
        if(2 * i <= size && heap[i] > heap[2 * i]) idx = 2 * i;
        if(2 * i + 1 <= size && heap[2 * i + 1] < heap[idx]) idx = 2 * i + 1;
        if(i != idx) {
            int tmp = heap[i];
            heap[i] = heap[idx];
            heap[idx] = tmp;
            down(idx);
        }
    }
    public int getMin() {
        int ret = heap[1];
        heap[1] = heap[this.size--];
        down(1);
        return ret;
    }
}
```

### 模拟堆
```
class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();

        Heap h = new Heap(n);
        int idx = 0;
        while(n > 0) {
            int k, x;
            String op = scan.next();
            switch(op) {
                case "I":
                    x = scan.nextInt();
                    h.size++;
                    idx++;
                    h.heap[h.size] = x;
                    h.ph[idx] = h.size;
                    h.hp[h.size] = idx;
                    h.up(h.size);
                    break;
                case "PM" :
                    System.out.println(h.heap[1]);
                    break;
                case "DM":
                    h.heap_swap(1, h.size);
                    h.size--;
                    h.down(1);
                    break;
                case "D" :
                    k = scan.nextInt();
                    k = h.ph[k];
                    h.heap_swap(k, h.size);
                    h.size--;
                    h.down(k);
                    h.up(k);
                    break;
                case "C":
                    k = scan.nextInt(); x = scan.nextInt();
                    k = h.ph[k]; // 必须提前记录下ph[k]的值，不然ph[k]的值可能会变
                    h.heap[k] = x;  
                    h.down(k);
                    h.up(k);
                    break;
            }
            n--;
        }
    }
}

class Heap {
    int size;
    int[] heap;
    //ph[k] 存的第k个点在堆里面的下标
    //hp[k] 存的是当前点在ph的下表
    int[] hp, ph;
    public Heap(int n) {
        this.size = 0;
        heap = new int[n + 1];
        hp = new int[n + 1];
        ph = new int[n + 1];
    }
    public  void swap(int[] arr, int x, int y) {
        int tmp = arr[x];
        arr[x] = arr[y];
        arr[y] = tmp;
    }
    public void heap_swap(int x, int y) {
        swap(ph, hp[x], hp[y]);
        swap(hp, x, y);  
        swap(heap, x, y);
    }
    public void down(int i) {
        int idx = i;
        if(2 * i <= size && heap[i] > heap[2 * i]) idx = 2 * i;
        if(2 * i + 1 <= size && heap[2 * i + 1] < heap[idx]) idx = 2 * i + 1;
        if(i != idx) {
            heap_swap(i, idx);
            down(idx);
        }
    }
    public void up(int i) {
        while(i / 2 != 0 && heap[i / 2] > heap[i]) {
            heap_swap(i / 2, i);
            i = i / 2;
        }
    }
}
```

## Hash
复杂度 O(1)  
注意:
1. 模的数取质数，这样可以保证冲突的数字尽可能小
2. 删除一般使用标记，不会真正的删除

### 开放寻址法：

只有一个数组，但是长度一般是输入数据的2～3倍
插入的话直接用 h.hash[h.find(x)] = x;
查找的话，直接看h.hash[h.find(x)] 是不是 0x3f3f3f。
模版：
```
//开放寻值法
class Hash {
    int n = 200003;
    int INF = 0x3f3f3f;
    int[] hash = new int[n];
    public Hash() {
        Arrays.fill(hash, INF);
    }
    // 如果存在，返回index 否则返回应该插入的index
    public int find(int x) {
        int index =  (x % n + n) % n;
        while(hash[index] != INF && hash[index] != x) {
            index++;
            if(index == hash.length) index = 0;
        }
        return index;
    }
}
```

### 拉链法 ： 数组 + 单链表
模版：
```
//拉链法
class Hash {
    int n = 100003;
    List<Integer>[] hash = new List[100003];

    public void insert(int x) {
        int index =  (x % n + n) % n;
        if(hash[index] == null) hash[index] = new ArrayList<>();
        hash[index].add(x);
    }
    public boolean find(int x) {
        int index =  (x % n + n) % n;
        if(hash[index] == null) return false;
        for(int i : hash[index]) {
            if(i == x) return true;
        }
        return false;
    }
}
```
### 字符串 hash
字符串前缀哈希法
注意：
- 不能映射成 0,  容易冲突. 否则， A 与 AA hash值一样。
- 如果P = 131 或者 13331， Q = 2 ^ 64 可以假设不存在冲突. 并且可以用 unsigned long long 来存储。不需要取模，溢出不需要处理。

```
e.g str =  "ABCAB"
h[0] = 0;
h[1] = "A" 的hash值
h[2] = "AB" 的hash值
h[3] = "ABC" 的hash值
h[4] = "ABCA" 的hash值

如何定义hash值：P进制法  
eg. ABCD -> (1,2,3,4)P = 1 * P^3 + 2 * P^2 + 3 * P^1 + 4 * P^0
最后模上Q 把它们映射到一个相对小的范围

(R)----(L-1)-(L)------(R)-----|
已知 h[R], h[L-1] 那么R 到 L的 hash 就是 h[R] - h[L] * P ^(R - L + 1)
```

模版：

```
class Main {
    static int N = 100010;
    static long[] p = new long[N];
    static long[] h = new long[N];
    static int P = 131;
    static long mod = Long.MAX_VALUE;
    static void init(char[] str) {
        p[0] = 1;
        for (int i = 1; i <=  str.length; i ++ ) {
            h[i] = (h[i - 1] * P + str[i - 1]) % mod;
            p[i] = p[i - 1] * P;
        }
    }

    static long query(int l, int r) {
        return h[r] - h[l-1] * p[r - l + 1];
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt(), m = scan.nextInt();
        char[] str = scan.next().toCharArray();
        init(str);
        while(m > 0) {
            int l1 = scan.nextInt(), r1 = scan.nextInt();
            int l2 = scan.nextInt(), r2 = scan.nextInt();
            if(query(l1, r1) == query(l2, r2)) System.out.println("Yes");
            else System.out.println("No");
            m--;
        }
    }
}
```


# 搜索与图论
## 深度优先搜索 DFS
permutation
n queens.
## BFS
当边权值为1的时候，才可以用bfs求最短路
## 图的存储
树： 连通无环图   
1. 邻接矩阵
2. 邻接表
## 拓扑序列
有向无环图一定存在拓扑序

## 最短路
1. 单源最短路  
   1. 只有正边(n 点 m 边)
    - 朴素 Dijkstra 算法 O(n^2) 边多的话，可以用这个
    - 堆优化版 Dijkstra 算法 O(mlogn) 稀疏图 可用这个  
   2. 存在负边  
    - Bellman-Ford O(nm)  
     这个算法可以用来找负环。 但是一般不用。

    - SPFA O(m), 最坏O(nm)
2. 多源最短路  
 - Floyd 算法 O(n^3)

## 最小生成树
1. prim  
prim 算法和 Dijstra 特别相似，但是一个是更新到源点的最短路径，而prim是每次挑出离当前求解过的连通集合的最短路
  - 朴素法 (n^2) 稠密图
  - 堆优化法 mlogn 稀疏图
2. Kruskal mlogn
使用并查集

## 二分图
染色法
二分图当且仅当图中不含奇数环 遍历图就可以了

匈牙利算法 O(mn) 实际运行时间远小于 O(mn)


# 数学知识
## 数论
1. 质数： 大于1的整数，如果只包含自己和1的约数，就是质数。
 - 质数的判定： 试除法 i < n / i 写成除法可以防止溢出。 时间复杂度sqrt(n)
 - 分解质因数， 试除法 从小到大枚举所有数 n 中最多只有一个大于sqrt n. 时间复杂度 sqrt(n)
 - 埃氏筛法 2-p-1 的所有质数倍数标记
   1～n 中有 n/ln(n)个质数。 n(1 + 1/2 + 1/4 + ... + 1/n) = nln(n)/ln(n) 约等于 O(n) 确切 O(nloglogn )
   线性筛法 n只会被最小质因子筛掉
2. 约数
  - 试除法
  - 约数个数
  - 约数之和  
  - 欧几里得算法 gcd
3. 欧拉函数
1.N - N /p1 - N/p2 ...  N/pk +  N/p1p2 ... N/pxpy ... - N/p1p2p3 +...N/p1p2p3p4
 加上 pi * pj的倍数 在减去三个数的倍数 ...
费马定理

4. 快速幂
求逆元
5. 扩展欧几里得算法
裴蜀定理： 有一对正整数  a, b 那么一定存在 x, y 使得 ax + by = gcd(a, b)

6. 容斥原理
能被2
7. 博弈类
 - Nim 游戏 先手必胜。把两堆石子拿成一样的状态，然后和对手保持一致
 - 公平组合游戏 ICG
 - 有向图游戏
 - Mex 运算

# 动态规划
1. 01背包
2. 完全背包
3. 多重背包
4. 分组背包
5. 计数问题： 分情况讨论
